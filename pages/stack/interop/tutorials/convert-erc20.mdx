---
title: Convert an ERC20 token into a SuperchainERC20 token
lang: en-US
description: Learn how to convert an ERC20 token into a SuperchainERC20 token
---

import { Callout } from 'nextra/components'
import { Steps } from 'nextra/components'

<Callout>
The SuperchainERC20 standard is ready for production use with active Mainnet deployments. 
Please note that the OP Stack interoperability upgrade, required for crosschain messaging, is currently still in active development.
</Callout>

The SuperchainERC20 contract implements ERC-7802 to enable asset interoperability within the Superchain. This tutorial guides you through converting an existing ERC20 token into a SuperchainERC20 token.

If you'd like a guided walkthrough, check out our [tutorial video](https://x.com/i/status/1866095114374045969) instead.

To learn more about the SuperchainERC20 standard, [look through our documentation](/stack/interop/superchain-erc20).

## SuperchainERC20 requirements

First let's chat about what your token will look like by the end of the conversion:

*   Implements the `ERC20` interface
*   Implements the `ERC7802` interface
*   Allows `SuperchainERC20Bridge` to call `crosschainMint` and `crosschainBurn`
*   Is deployed at the same address on every chain in the Superchain

This implementation allows a token to be bridged between two chains. This means the `SuperchainERC20Bridge` mints the token on the new chain and burns them on the original chain.

## Convert your ERC20 tokens

<Steps>

### Create a basic ERC20 contract

The following code implements a basic ERC20 contract:

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";

contract MyERC20 is ERC20, Ownable {
    constructor(address owner, string memory name, string memory symbol) ERC20(name, symbol) Ownable(owner) {}

    function mint(address to, uint256 amount) public onlyOwner {
        _mint(to, amount);
    }
}

```

### Add the new SuperchainERC20 interface 

The first step is simply to implement `IERC7802` and `IERC165`. Note that we've renamed the contract at this point:

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {ERC165} from "@openzeppelin/contracts/interfaces/IERC165.sol";
import {IERC7802} from "@openzeppelin/contracts/token/ERC20/IERC7802.sol";

contract MySuperchainERC20 is ERC20, Ownable, IERC7802 {
    error NotSuperchainERC20Bridge();

    constructor(address owner, string memory name, string memory symbol) ERC20(name, symbol) Ownable(owner) {}

    function mint(address to, uint256 amount) public onlyOwner {
        _mint(to, amount);
    }


    function supportsInterface(bytes4 _interfaceId) public view virtual returns (bool) {
        return _interfaceId == type(IERC7802).interfaceId || 
               _interfaceId == type(ERC20).interfaceId 
               || _interfaceId == type(ERC165).interfaceId;
    }
}

```

### Implement burn and mint functions

There are two functions we need to implement: `CrosschainMint` and `CrosschainBurn`. These two functions allow two chains to bridge a token by burning them on one chain and mint them on another. Read more about these functions in our [SuperchainERC20 docs](/stack/interop/superchain-erc20).

Here's what our contract looks like once we've implemented the functions:


```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {ERC165} from "@openzeppelin/contracts/interfaces/IERC165.sol";
import {IERC7802} from "@openzeppelin/contracts/token/ERC20/IERC7802.sol";

contract MySuperchainERC20 is ERC20, Ownable, IERC7802 {
    error NotSuperchainERC20Bridge();

    constructor(address owner, string memory name, string memory symbol) ERC20(name, symbol) Ownable(owner) {}

    function mint(address to, uint256 amount) public onlyOwner {
        _mint(to, amount);
    }

    /// @notice Allows the SuperchainTokenBridge to mint tokens.
    /// @param _to Address to mint tokens to.
    /// @param _amount Amount of tokens to mint.
    function crosschainMint(address _to, uint256 _amount) external {
        if (msg.sender != 0x4200000000000000000000000000000000000028) revert NotSuperchainERC20Bridge();

        _mint(_to, _amount);

        emit CrosschainMint(_to, _amount, msg.sender);
    }

    /// @notice Allows the SuperchainTokenBridge to burn tokens.
    /// @param _from Address to burn tokens from.
    /// @param _amount Amount of tokens to burn.
    function crosschainBurn(address _from, uint256 _amount) external {
        if (msg.sender != 0x4200000000000000000000000000000000000028) revert NotSuperchainERC20Bridge();
        
        _burn(_from, _amount);

        emit CrosschainBurn(_from, _amount, msg.sender);
    }

    function supportsInterface(bytes4 _interfaceId) public view virtual returns (bool) {
        return _interfaceId == type(IERC7802).interfaceId || 
               _interfaceId == type(ERC20).interfaceId 
               || _interfaceId == type(ERC165).interfaceId;
    }
}
```

</Steps>

## Next steps
*   Use the [SuperchainERC20 Starter Kit](/app-developers/starter-kit) to deploy your token across the Superchain.
*   Explore the [SuperchainERC20 specifications](https://specs.optimism.io/interop/token-bridging.html) for in-depth implementation details.
*   Review the [Superchain Interop Explainer](/stack/interop/explainer) for answers to common questions about interoperability.