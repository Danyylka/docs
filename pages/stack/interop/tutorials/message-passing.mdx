---
title: Interop message passing tutorial
lang: en-US
description: Learn how to pass messages from one superchain blockchain to another
---

import { Callout } from 'nextra/components'
import { Steps } from 'nextra/components'
import { InteropCallout } from '@/components/WipCallout'

<InteropCallout />

# Interop message passing tutorial

<Callout>
  This is a step-by-step tutorial.
  You can find an explanation of how this works [here](../message-passing).
</Callout>

In this tutorial you learn how to use the [`L2ToL2CrossDomainMessenger`](https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/L2/L2ToL2CrossDomainMessenger.sol) contract to pass a message from one interop blockchain to another.

In this tutorial we will use several tools:

- The [Supersim multichain development environment](../tools/supersim)
- [Foundry](https://book.getfoundry.sh/)
- [Viem](https://viem.sh/)
- [Node](https://nodejs.org/en)
- [TypeScript](https://www.typescriptlang.org/)
- UNIX. 
  This tutorial is designed to run either on Linux or MacOS. 
  If you use Windows, you can use the [Windows Subsystem for Linux (WSL)](https://learn.microsoft.com/en-us/windows/wsl/install).


## Install tools

<Steps>

### Foundry

Download and install [Foundry].
Part of Foundry is [`anvil`](https://book.getfoundry.sh/anvil/), which runs a local Ethereum node.

### Supersim

Download and install [Supersim](https://github.com/ethereum-optimism/supersim/releases).

</Steps>

## Solidity message passing

In this section you create contracts and transfer a message between them.
For now, we ignore the need for executing messages by turning on autorelay.
Look below for an explanation how to relay your own messages.

<Steps>

### Run the chains

1. In the directory where Supersim is installed, start it with autorelay.

    ```sh
    ./supersim --interop.autorelay
    ```

    Supersim creates three `anvil` blockchains:

    | Role | ChainID | RPC URL |
    | - | -: | - |
    | L1 | 900 | http://127.0.0.1:8545 
    | OPChainA | 901 | http://127.0.0.1:9545 
    | OPChainB | 902 | http://127.0.0.1:9546  

1. In a separate shell, store the configuration in environment variables.

    ```sh
    USER_ADDR=0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266
    PRIV_KEY=0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80
    RPC_L1=http://localhost:8545
    RPC_A=http://localhost:9545
    RPC_B=http://localhost:9546
    ```

1. To verify that the chains are running, check the balance of `$ADDR`.

    ```sh
    cast balance --ether $USER_ADDR --rpc-url $RPC_L1
    cast balance --ether $USER_ADDR --rpc-url $RPC_A
    cast balance --ether $USER_ADDR --rpc-url $RPC_B        
    ```

### Create the contracts

1. Create a new Foundry project.

   ```sh
   mkdir onchain-code
   cd onchain-code
   forge init
   ```

1. In `src/Greeter.sol` put this file.
   This is a variation on [Hardhat's Greeter contract](https://github.com/matter-labs/hardhat-zksync/blob/main/examples/upgradable-example/contracts/Greeter.sol).

    ```solidity
    //SPDX-License-Identifier: MIT
    pragma solidity ^0.8.0;

    contract Greeter {
        string greeting;

        event SetGreeting(
            address indexed sender,     // msg.sender
            string greeting
        ); 

        function greet() public view returns (string memory) {
            return greeting;
        }

        function setGreeting(string memory _greeting) public {
            greeting = _greeting;
            emit SetGreeting(msg.sender, _greeting);
        }
    }
    ```

1. Deploy the contract to chain B and set `GREETER_B_ADDR` to the address for the contract.

    ```sh
    GREETER_B_ADDR=`forge create --rpc-url $RPC_B --private-key $PRIV_KEY Greeter --broadcast | awk '/Deployed to:/ {print $3}'`
    ```

    <details>

    <summary>Explanation</summary>

    The command that deploys the contract is:

    ```sh
    forge create --rpc-url $RPC_B --private-key $PRIV_KEY Greeter --broadcast
    ```

    The command output gives us the deployer address, the address of the new contract, and the transaction hash:

    ```
    Deployer: 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266
    Deployed to: 0x5FC8d32690cc91D4c39d9d3abcBD16989F875707
    Transaction hash: 0xf155d360ec70ee10fe0e02d99c16fa5d6dc2a0e79b005fec6cbf7925ff547dbf
    ```

    The [`awk`](https://www.tutorialspoint.com/awk/index.htm) command looks for the line that has `Deployed to:` and writes the third word in that line, which is the address.

    ```sh
    awk '/Deployed to:/ {print $3}'
    ```

    Finally, in UNIX (including Linux and MacOS) the when the command line includes backticks (`\``), the shell executes the code between the backticks and puts the output, in this case the contract address, in the command.
    So we get.

    ```sh
    GREETER_B_ADDR=<the address>
    ```

    </details>

1. Run these commands to verify the contract works.
   The first and third commands read the greeting, and the second submit a transaction that changes it.

   ```sh
   cast call --rpc-url $RPC_B $GREETER_B_ADDR "greet()" | cast --to-ascii 
   cast send --private-key $PRIV_KEY --rpc-url $RPC_B $GREETER_B_ADDR "setGreeting(string)" Hello
   cast call --rpc-url $RPC_B $GREETER_B_ADDR "greet()" | cast --to-ascii
   ```

1. Install the Optimism Solidity libraries into the project.

    ```sh
    cd lib
    npm add @eth-optimism/contracts-bedrock
    cd ..
    echo @eth-optimism/=lib/node_modules/@eth-optimism/ >> remappings.txt
    ```

1. The [`@eth-optimism/contracts-bedrock`](https://www.npmjs.com/package/@eth-optimism/contracts-bedrock) library does not have the Interop Solidity code yet.
   Run these commands to add it.

   ```sh
   mkdir -p lib/node_modules/@eth-optimism/contracts-bedrock/interfaces/L2
   wget https://raw.githubusercontent.com/ethereum-optimism/optimism/refs/heads/develop/packages/contracts-bedrock/interfaces/L2/IL2ToL2CrossDomainMessenger.sol
   mv IL2ToL2CrossDomainMessenger.sol lib/node_modules/@eth-optimism/contracts-bedrock/interfaces/L2
   ```

1. Create `src/GreetingSender.sol`.

    ```solidity
    //SPDX-License-Identifier: MIT
    pragma solidity ^0.8.0;

    import { Predeploys } from "@eth-optimism/contracts-bedrock/src/libraries/Predeploys.sol";
    import { IL2ToL2CrossDomainMessenger } from "@eth-optimism/contracts-bedrock/interfaces/L2/IL2ToL2CrossDomainMessenger.sol";

    import { Greeter } from "src/Greeter.sol";

    contract GreetingSender {
        IL2ToL2CrossDomainMessenger public immutable messenger =
            IL2ToL2CrossDomainMessenger(Predeploys.L2_TO_L2_CROSS_DOMAIN_MESSENGER);

        address immutable greeterAddress;
        uint256 immutable greeterChainId;

        constructor(address _greeterAddress, uint256 _greeterChainId) {
            greeterAddress = _greeterAddress;
            greeterChainId = _greeterChainId;
        }

        function setGreeting(string calldata greeting) public {
            bytes memory message = abi.encodeCall(
                Greeter.setGreeting,
                (greeting)
            );
            messenger.sendMessage(greeterChainId, greeterAddress, message);
        }
    }
    ```

    <details>

    <summary>Explanation</summary>

    ```solidity
    function setGreeting(string calldata greeting) public {
        bytes memory message = abi.encodeCall(
            Greeter.setGreeting,
            (greeting)
        );
    ```

    The message is the [calldata](https://docs.soliditylang.org/en/latest/internals/layout_in_calldata.html) sent to the destination contract.
    The easiest way to calldata is the use [`abi.encodeCall`](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#abi-encoding-and-decoding-functions).


    ```solidity
        messenger.sendMessage(greeterChainId, greeterAddress, message);
    }
    ```

    Actually send the message using [`L2ToL2CrossDomainMessenger.sendMessage`](https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/L2/L2ToL2CrossDomainMessenger.sol#L128-L154).

    </details>

1. Deploy `GreetingSender` to chain A.

    ```sh
    GREETER_A_ADDR=`forge create --rpc-url $RPC_A --private-key $PRIV_KEY --broadcast GreetingSender --constructor-args $GREETER_B_ADDR 902 | awk '/Deployed to:/ {print $3}'`
    ```

### Send a message

Send a greeting from chain A to chain B.

```sh
cast call --rpc-url $RPC_B $GREETER_B_ADDR "greet()" | cast --to-ascii 
cast send --private-key $PRIV_KEY --rpc-url $RPC_A $GREETER_A_ADDR "setGreeting(string)" "Hello from chain A"
sleep 2
cast call --rpc-url $RPC_B $GREETER_B_ADDR "greet()" | cast --to-ascii
```

The `sleep` call is because the message is not relayed until the next chain B block, which can take up to two seconds.

</Steps>

## Sender information

Run this command to view the events to see who called `setGreeting`.

```sh
cast logs --rpc-url $RPC_B 'SetGreeting(address,string)'
```

The sender is the second topic.
However, when the greetings come from a separate blockchain, that value is just the address of the local `L2ToL2CrossDomainMessenger` contract, which is always `4200000000000000000000000000000000000023`.
That is not useful.

In this section we change `Greeter.sol` to report 

<Steps>

### Modify the Greeter contract

1. Modify `src/Greeter.sol` to this code.

    ```solidity
    //SPDX-License-Identifier: MIT
    pragma solidity ^0.8.0;

    import { Predeploys } from "@eth-optimism/contracts-bedrock/src/libraries/Predeploys.sol";
    import { IL2ToL2CrossDomainMessenger } from "@eth-optimism/contracts-bedrock/interfaces/L2/IL2ToL2CrossDomainMessenger.sol";    

    contract Greeter {

        IL2ToL2CrossDomainMessenger public immutable messenger =
            IL2ToL2CrossDomainMessenger(Predeploys.L2_TO_L2_CROSS_DOMAIN_MESSENGER);

        string greeting;

        event SetGreeting(
            address indexed sender,     // msg.sender
            string greeting
        ); 

        event CrossDomainSetGreeting(
            address indexed sender,   // Sender on the other side
            uint256 indexed chainId,  // ChainID of the other side
            string greeting
        );

        function greet() public view returns (string memory) {
            return greeting;
        }

        function setGreeting(string memory _greeting) public {
            greeting = _greeting;
            emit SetGreeting(msg.sender, _greeting);

            if (msg.sender == Predeploys.L2_TO_L2_CROSS_DOMAIN_MESSENGER) {
                (address sender, uint256 chainId) =
                    messenger.crossDomainMessageContext();              
                emit CrossDomainSetGreeting(sender, chainId, _greeting);
            }
        }
    }
    ```   

    <details>

    <summary>Explanation</summary>

    If we see that we got a message from `L2ToL2CrossDomainMessenger`, we call [`L2ToL2CrossDomainMessenger.crossDomainMessageContext`](https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/L2/L2ToL2CrossDomainMessenger.sol#L118-L126).

    </details>

1. Redeploy the contracts.
   Because the address of `Greeter` is immutable in `GreetingSender`, we need to redeploy both contracts.

    ```sh
    GREETER_B_ADDR=`forge create --rpc-url $RPC_B --private-key $PRIV_KEY Greeter --broadcast | awk '/Deployed to:/ {print $3}'`
    GREETER_A_ADDR=`forge create --rpc-url $RPC_A --private-key $PRIV_KEY --broadcast GreetingSender --constructor-args $GREETER_B_ADDR 902 | awk '/Deployed to:/ {print $3}'`
    ```

### Verify you can see cross chain sender information

1. Set the greeting through `GreetingSender`.

    ```sh
    cast call --rpc-url $RPC_B $GREETER_B_ADDR "greet()" | cast --to-ascii 
    cast send --private-key $PRIV_KEY --rpc-url $RPC_A $GREETER_A_ADDR "setGreeting(string)" "Hello from chain A, with an event"
    sleep 2
    cast call --rpc-url $RPC_B $GREETER_B_ADDR "greet()" | cast --to-ascii
    ```    

1. Read the log entries.

    ```sh
    cast logs --rpc-url $RPC_B 'CrossDomainSetGreeting(address,uint256,string)'
    echo $GREETER_A_ADDR
    echo 0x385 | cast --to-dec
    ```

    See that the second topic (the first indexed log parameter) is the same as `$GREETER_A_ADDR`.
    The third topic is `0x385=901`, which is the chain ID for chain A.

</Steps>

## Javascript message relaying

So far we relied on `--interop.autorelay` to send the executing messages to chain B.
But we only have it because we're using a development system.
In production we will not have this, we need to create our own executing messages.

<Steps>

### Set up

We are going to use a [Node](https://nodejs.org/en) project, to be able to get executing messages from the command line.
We use [TypeScript](https://www.typescriptlang.org/) to have type safety combined with JavaScript functionality.

1. Initialize a new Node project.

    ```sh
    mkdir ../offchain-code
    cd ../offchain-code
    npm init -y
    npm install --save-dev -y viem tsx @types/node @eth-optimism/viem
    mkdir src
    ```

1. Edit `package.json` to add the `start` script.

    ```json
    {
        "name": "offchain-code",
        "version": "1.0.0",
        "main": "index.js",
        "scripts": {
            "test": "echo \"Error: no test specified\" && exit 1",
            "start": "tsx src/app.mts"
        },
        "keywords": [],
        "author": "",
        "license": "ISC",
        "type": "commonjs",
        "description": "",
        "devDependencies": {
            "@eth-optimism/viem": "^0.3.0",
            "@types/node": "^22.13.1",
            "tsx": "^4.19.2",
            "viem": "^2.22.23"
        }
    }
    ```

1. Export environment variables.
   This is necessary because those variables are currently limited to the shell process.
   We need them in the Node process that the shell creates.

    ```sh
    export GREETER_A_ADDR GREETER_B_ADDR PRIV_KEY RPC_A RPC_B
    ```

1. Create a simple `src/app.mts` file.

    ```typescript
    console.log(`Chain A: ${process.env.RPC_A}\tGreeter ${process.env.GREETER_A_ADDR}`)
    console.log(`Chain B: ${process.env.RPC_B}\tGreeter ${process.env.GREETER_B_ADDR}`)
    ```    

1. Run the program.

    ```sh
    npm run start
    ```

### Send a greeting 

1. Link the compiled versions of the code, which include the ABI, to the source code.

    ```sh
    cd src
    ln -s ../../onchain-code/out/Greeter.sol/Greeter.json .
    ln -s ../../onchain-code/out/GreetingSender.sol/GreetingSender.json .
    cd ..
    ```

1. Replace `src/app.mts` with this code.

    ```typescript
    import {
        createWalletClient,
        http,
        defineChain,
        publicActions,
        getContract,
        Address,
    } from 'viem'
    import { privateKeyToAccount } from 'viem/accounts'
    import { supersimL2A, supersimL2B } from '@eth-optimism/viem/chains'


    import greeterData from './Greeter.json'
    import greetingSenderData from './GreetingSender.json'

    const account = privateKeyToAccount(process.env.PRIV_KEY as `0x${string}`)

    const walletA = createWalletClient({
        chain: supersimL2A,
        transport: http(),
        account
    }).extend(publicActions)

    const walletB = createWalletClient({
        chain: supersimL2B,
        transport: http(),
        account
    }).extend(publicActions)

    const greeter = getContract({
        address: process.env.GREETER_B_ADDR as Address,
        abi: greeterData.abi,
        client: walletB
    })

    const greetingSender = getContract({
        address: process.env.GREETER_A_ADDR as Address,
        abi: greetingSenderData.abi,
        client: walletA
    })
    const txnBHash = await greeter.write.setGreeting(["Greeting directly to chain B"])
    await walletB.waitForTransactionReceipt({hash: txnBHash})

    const greeting1 = await greeter.read.greet()
    console.log(`Chain B Greeting: ${greeting1}`)

    const txnAHash = await greetingSender.write.setGreeting(["Greeting through chain A"])
    await walletA.waitForTransactionReceipt({hash: txnAHash})

    const greeting2 = await greeter.read.greet()
    console.log(`Chain A Greeting: ${greeting2}`)
    ```

3. Run the program, see that a greeting from chain A is related to chain B.

   ```sh
   npm start
   ```

### Rerun supersim


</Steps>